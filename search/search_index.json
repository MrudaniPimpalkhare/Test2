{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Obsidian Notes","text":"<p>Publish your public notes with MkDocs</p>"},{"location":"#hello-world","title":"Hello World!","text":"<p>The <code>index.md</code> in the <code>/docs</code> folder is the homepage you see here.</p> <p>The folders in <code>/docs</code> appear as the main sections on the navigation bar.</p> <p>The notes appear as pages within these sections. For example, Note 1 in <code>Topic 1</code></p>"},{"location":"Features/LaTeX%20Math%20Support/","title":"LaTeX Math Support","text":"<p>LaTeX math is supported using MathJax.</p> <p>Inline math looks like \\(f(x) = x^2\\). The input for this is <code>$f(x) = x^2$</code>. Use <code>$...$</code>.</p> <p>For a block of math, use <code>$$...$$</code> on separate lines</p> <pre><code>$$\nF(x) = \\int^a_b \\frac{1}{2}x^4\n$$\n</code></pre> <p>gives </p> \\[ F(x) = \\int^a_b \\frac{1}{2}x^4 \\]"},{"location":"Features/Mermaid%20Diagrams/","title":"Mermaid diagrams","text":"<p>Here's the example from MkDocs Material documentation: </p> <pre><code>graph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];</code></pre>"},{"location":"Features/Text%20Formatting/","title":"Text Formatting","text":"<p>You can have lists like this</p> <ul> <li>first</li> <li>second</li> <li>third</li> </ul> <p>Or checklist lists to</p> <ul> <li> Get</li> <li> things</li> <li> done</li> </ul> <p>Also, get highlights and strikethroughs as above (similar to Obsidian).</p> <p>More formatting options for your webpage here. (but not compatible with Obsidian)</p>"},{"location":"Manim/Building%20Blocks%20of%20Manim/","title":"Building Blocks of Manim","text":"<ul> <li>To understand placements and alignment of the objects , I would assume you have read General Animation in Manim#^458fb2 so to get how the objects are created and gets added into the working canvas, that's only when you will understand the further concepts.</li> </ul>"},{"location":"Manim/Building%20Blocks%20of%20Manim/#shift","title":"Shift","text":"<p>.Shift({Amount} \\(*\\) Direction)  to align the objects from center. - So this would become: <pre><code> circle = Circle()\n        square = Square()\n        triangle = Triangle()\n\n        circle.shift(1*LEFT)\n        square.shift(1*UP)\n        triangle.shift(1*RIGHT)\n\n        self.add(circle, square, triangle)\n</code></pre> </p>"},{"location":"Manim/Building%20Blocks%20of%20Manim/#set_stroke-set_fill","title":"set_stroke || set_Fill","text":"<ul> <li>set_fill accepts two parameters , color and opacity.</li> <li>set_stroke accepts two parameters, color and width. So this would again become: <pre><code>  circle = Circle().shift(LEFT)\n        square = Square().shift(UP)\n        triangle = Triangle().shift(RIGHT)\n\n        circle.set_stroke(color=GREEN, width=20)\n        square.set_fill(YELLOW, opacity=1.0)\n        triangle.set_fill(PINK, opacity=0.5)\n\n        self.add(circle, square, triangle)\n</code></pre> </li> </ul>"},{"location":"Manim/Building%20Blocks%20of%20Manim/#fadein-fadeout","title":"FadeIn || FadeOut","text":"<ul> <li>FadeIn is used with self.play(FadeIn(mobject)) to fade in the object.</li> <li>Same with FadeOut, Rotate accepts two parameters , if not just keeps rotating till it's runtime. <pre><code>from manim import *\n\nclass SomeAnimations(Scene):\n    def construct(self):\n        square = Square()\n\n        self.play(FadeIn(square))\n\n        self.play(Rotate(square, PI/4))\n\n        self.play(FadeOut(square))\n\n        self.wait(1)\n</code></pre> Output: </li> </ul>"},{"location":"Manim/Building%20Blocks%20of%20Manim/#rotate","title":"Rotate:","text":"<p><pre><code>class\u00a0Rotate(mobject=None,\u00a0*args,\u00a0use_override=True,\u00a0**kwargs)\n</code></pre> Animation that rotates a Mobject.</p> <p>PARAMETERS:</p> <ul> <li> <p>mobject\u00a0(Mobject) \u2013 The mobject to be rotated.</p> </li> <li> <p>angle\u00a0(float) \u2013 The rotation angle.</p> </li> <li> <p>axis\u00a0(np.ndarray) \u2013 The rotation axis as a numpy vector.</p> </li> <li> <p>about_point\u00a0(Sequence__[__float__] | None) \u2013 The rotation center.</p> </li> <li> <p>about_edge\u00a0(Sequence__[__float__] | None) \u2013 If\u00a0<code>about_point``is\u00a0``None</code>, this argument specifies the direction of the bounding box point to be taken as the rotation center. <pre><code>from manim import *\n\n\n\nclass Rotation(Scene):\n\ndef construct(self):\n\nsquare = Square(color=BLUE)\n\nself.play(Create(square))\n\nself.play(\n\nRotate(\n\nsquare,\n\nangle=PI/4,\n\nabout_point = ORIGIN,\n\nrate_func = linear,\n\nrun_time = 3,\n\n),\n\n)\n\nself.remove(square)\n\nself.wait()\n\ncircle = Circle(color=RED)\n\nself.play(Create(circle))\n\nself.play(circle.animate.shift(2*UP))\n\nself.play(\n\nRotate(\n\ncircle,\n\nangle=PI/4,\n\nabout_point = ORIGIN,\n\nrate_func = linear,\n\nrun_time = 3,\n\n),\n\n)\n</code></pre> </p> </li> </ul>"},{"location":"Manim/Building%20Blocks%20of%20Manim/#move_to-next_to-edge_to-grow_from_center","title":"move_to || next_to || edge_to || grow_from_center","text":"<ul> <li>move_to:     <pre><code>    obj.move_to(point_or_mobject, aligned_edge=UP)\n</code></pre></li> <li>next_to     <pre><code>obj.next_to(mobject, direction=RIGHT, buff=0.1)\n</code></pre></li> <li>edge_to     <pre><code>obj.edge_to(point_or_mobject, direction=RIGHT)\n</code></pre></li> <li>grow_from_center     <pre><code>obj.grow_from_center(scale_factor=1.2)\n</code></pre></li> <li>grow_from_edge <pre><code>self.play(GrowFromEdge(triangle, DOWN))\n</code></pre></li> <li>grow_from_point <pre><code> self.play(GrowFromPoint(square, ORIGIN))\n</code></pre></li> </ul>"},{"location":"Manim/Building%20Blocks%20of%20Manim/#custom-example-using-building-blocks","title":"Custom Example Using Building Blocks","text":"<ul> <li>Here's a code that I will further explain step by step, first let's see the output and code. <pre><code>from manim import *\n\n\nclass Custom(Scene):\n\ndef construct(self):\n\nsquare = Square()\n\nsquare.set_fill(RED, opacity=0.6)\n\nself.play(Create(square))\n\nself.play(Rotate(square, PI/4))\n\nself.play(square.animate.set_stroke(YELLOW, width=20),runtime =2)\n\nsquare.set_stroke(BLUE, width=10)\n\nself.wait(2)\n\nself.play(square.animate.set_fill(GREEN, opacity=0.2),runtime =2)\n\ntriangle = Triangle()\n\nself.play(square.animate.shift(3*UP).rotate(PI/4).scale(2),runtime = 3)\n\nself.play(ReplacementTransform(square, triangle),runtime = 3)\n</code></pre> </li> <li>Here we used our knowledge of animate method along with building blocks to understand how to animate stuff in manim, first we are creating a square , then we learnt above that to fill it any color we would use set fill, now we remember we had already done set fill before the animation in self.play right?</li> <li>So what happens is it renders the red block directly, to explain this further I have used Rotate which as I explained a way to rotate that mobject,now we want to set a stroke but we also want to animate it then we use .animate.set_stroke rather than just doing it directly, you can see in the video what happens if we do it directly, we used self.wait() to observe that frame and grasp it fully, then we saw how fill can be animated as well.</li> <li> <p>Now for the shift up, if we would have just shifted up it would not have rotated, but we also want to rotate it and scale it twice, so we use multiple parameters methods here and you can also not specify the runtime, but it's a good practice to do so for convenience of understanding how your animation will look like, then we use ReplacementTransform function which you can find Common Functions in Manim#^3e9409 here. To morph triangle into the square. </p> </li> <li> <p>I now recommend going to General Animation in Manim#^ed7255 and you will understand it a lot better. :)</p> </li> </ul>"},{"location":"Manim/Common%20Functions%20in%20Manim/","title":"Common Functions in Manim","text":"<p>This will contain list of some useful functions ,which I find useful haha, almost every function is useful but I just prefer these.</p>"},{"location":"Manim/Common%20Functions%20in%20Manim/#replacementtransform","title":"ReplacementTransform","text":"<p>^3e9409</p> <ul> <li> <p>Replaces and morphs a mobject into a target mobject.     ### Parameters</p> <p>mobject \u00a0\u00a0\u00a0\u00a0The starting\u00a0<code>~.Mobject</code>. target_mobject \u00a0\u00a0\u00a0\u00a0The target\u00a0<code>~.Mobject</code>.</p> </li> </ul>"},{"location":"Manim/Common%20Functions%20in%20Manim/#tracedpath","title":"TracedPath","text":"<p>^9c76cd</p> <p><pre><code>class\u00a0TracedPath(traced_point_func,\u00a0stroke_width=2,\u00a0stroke_color=ManimColor('#FFFFFF'),\u00a0dissipating_time=None,\u00a0**kwargs)\n</code></pre> PARAMETERS:</p> <ul> <li> <p>traced_point_func\u00a0(Callable) \u2013 The function to be traced.</p> </li> <li> <p>stroke_width\u00a0(float) \u2013 The width of the trace.</p> </li> <li> <p>stroke_color\u00a0(ParsableManimColor | None) \u2013 The color of the trace.</p> </li> <li> <p>dissipating_time\u00a0(float | None) \u2013 The time taken for the path to dissipate. Default set to\u00a0<code>None</code>\u00a0which disables dissipation.</p> </li> </ul>"},{"location":"Manim/Common%20Functions%20in%20Manim/#vgroup","title":"Vgroup","text":"<ul> <li>Merges mobjects so that it is easier to perform animations on them: Example: <pre><code>from manim import *\n\nclass VGroupExample(Scene):\n\ndef construct(self):\n\nCircle1 = Circle()\n\nCircle1.set_fill(RED, opacity=0.6)\n\nCircle1.shift(2*LEFT) # so that the Circles do not overlap\n\nCircle2 = Circle()\n\nCircle2.set_fill(GREEN, opacity=0.6)\n\nCircle2.shift(2*RIGHT) # so that the Circles do not overlap\n\nCircle3 = Circle()\n\nCircle3.set_fill(BLUE, opacity=0.6)\n\nvgroup1 = VGroup(Circle1 , Circle2)\n\nvgroup2 = VGroup(Circle3)\n\nself.add(vgroup1,vgroup2)\n\nself.wait(1)\n\nself.play(vgroup1.animate.shift(2*UP))\n\nself.play(vgroup2.animate.shift(2*DOWN))\n\nvgroup1+=vgroup2\n\nself.wait(1)\n\nself.play(vgroup1.animate.rotate(PI/4))\n\nvgroup1.set_fill(YELLOW, opacity=0.6)\n\nself.wait(1)\n\nvgroup1-=vgroup2\n\nself.play(vgroup1.animate.rotate(PI/4))\n\nself.play(vgroup1.animate.scale(1.5), #animate groups separately\n\nvgroup2.animate.scale(0.5))\n\nself.play((vgroup1+vgroup2).animate.shift(2*RIGHT)) #animate groups together without modification\n\nself.play((vgroup1-Circle1).animate.shift(2*LEFT)) #animate group without a singular component\n\nself.wait(1)\n</code></pre> Output: </li> </ul>"},{"location":"Manim/Common%20Functions%20in%20Manim/#add_updater","title":"add_updater","text":"<p>^561871</p> <ul> <li>Add an update function to the scene.     The scene updater functions are run every frame, and they are the last type of updaters to run. usually takes a point,  to be specific a float as a parameter and can be used like this:  This might get confusing but just look at what pointer does.. basically it updates every frame so you will see it will follow your Tracker, we will get into this once we have covered animation basics. <pre><code>from manim import *\n\nclass ValueTrackerExample(Scene):\n    def construct(self):\n        number_line = NumberLine()\n        pointer = Vector(DOWN)\n        label = MathTex(\"x\").add_updater(lambda m: m.next_to(pointer, UP))\n\n        tracker = ValueTracker(0)\n        pointer.add_updater(\n            lambda m: m.next_to(\n                        number_line.n2p(tracker.get_value()),\n                        UP\n                    )\n        )\n        self.add(number_line, pointer,label)\n        tracker += 1.5\n        self.wait(1)\n        tracker -= 4\n        self.wait(0.5)\n        self.play(tracker.animate.set_value(5)),\n        self.wait(0.5)\n        self.play(tracker.animate.set_value(3))\n        self.play(tracker.animate.increment_value(-2))\n        self.wait(0.5)\n</code></pre> </li> </ul> <p>^1baea5</p>"},{"location":"Manim/General%20Animation%20in%20Manim/","title":"General Animation in Manim","text":"<ul> <li>General Idea of animation in Manim is that you mobjects inside a self and then we play it, in the simplest terms.</li> </ul>"},{"location":"Manim/General%20Animation%20in%20Manim/#an-animation","title":"An animation.","text":"<p>Animations have a fixed time span.</p> <p>PARAMETERS:</p> <ul> <li>mobject\u00a0\u2013 The mobject to be animated. This is not required for all types of animations.</li> <li>run_time\u00a0\u2013 The duration of the animation in seconds.</li> </ul>"},{"location":"Manim/General%20Animation%20in%20Manim/#example-essential","title":"Example (Essential):","text":"<p>^458fb2</p> <p><pre><code>from manim import *\n\n\nclass AnimationExample(Scene):\n\ndef construct(self):\n\ncircle = Circle()\n\nsquare = Square()\n\ntriangle = Triangle()\n\nself.add(circle)\n\nself.wait(2)\n\nself.remove(circle)\n\nself.play(ShowCreationThenFadeOut(square),runtime = 3)\n\n#or\n\nself.play(Create(triangle))\n\nself.play(Rotating(triangle))\n\nself.play(FadeOut(triangle))\n</code></pre> Output:  - Explanation Line by Line:     - First line as I mentioned we create a class that we work on, so to play this we would have done in the terminal:     <pre><code>manim Example.py AnimationExample -pqh\n</code></pre></p> <pre><code>- So we define the construct method on self as the parameter.\n- Then we use from the [Mobjects in Manim](&lt;./Mobjects in Manim.md&gt;) circle, Square and Triangle and grab them inside the variables we have defined.\n- Now the important part of animation..\n- Imagine Self as a canvas so when you just do **add** it adds it into the canvas, we will learn about it's placement later on in this but as of now just understand that when we do self.add(stuff), we are adding that stuff into the canvas, as you can see from the video , that doesn't really have any animation but when we have done that on the square  we have used ShowCreationThenFadeOut which will give you a warning but that's okay , it's just a good practice to use the other option that I showed in triangle that to create it first and then fade it out, I will list other useful function here as well, which you can use for animation. \n-  Self.wait({seconds}), accepts seconds as the input and you can specify the runtime which also takes values in seconds as I have done for square creation.\n</code></pre> <ul> <li>Before we dwell more into examples, be sure to learn and understand the Building Blocks of Manim. </li> </ul>"},{"location":"Manim/General%20Animation%20in%20Manim/#tracing-objects","title":"Tracing Objects:","text":"<ul> <li>So in manim we can trace objects using Common Functions in Manim#^9c76cd ,Common Functions in Manim#^561871 and Common Functions in Manim#^1baea5</li> <li>Here move_to basically means the object will move to that place where we have pointed, and circ.get_start means the dot in the canvas where the circles started from.</li> </ul> <p>Example: <pre><code>from manim import *\n\n\n\nclass Tracing(Scene):\n\ndef construct(self):\n\ncirc = Circle(color=RED).shift(4*LEFT)\n\ndot = Dot(color=RED).move_to(circ.get_start())\n\nrolling_circle = VGroup(circ, dot)\n\ntrace = TracedPath(circ.get_start)\n\nrolling_circle.add_updater(lambda m: m.rotate(-0.4))\n\nself.add(trace, rolling_circle)\n\n# self.wait()\n\nself.play(rolling_circle.animate.shift(8*RIGHT),rate_func = linear, run_time = 4)\n\n# self.wait()\n\nrolling_circle.clear_updaters()\n\ntrace.clear_updaters()\n\ntrace2 = TracedPath(circ.get_start, dissipating_time=0.4, stroke_width=5, stroke_color=BLUE)\n\nself.add(trace2, rolling_circle)\n\nrolling_circle.add_updater(lambda m: m.rotate(+0.2))\n\nself.play(rolling_circle.animate.shift(8*LEFT), run_time=4,rate_func = linear)\n</code></pre>  - Here we have used the previously discussed function and different type of tracing by modifying parameters.  ^ed7255</p>"},{"location":"Manim/Introduction%20to%20Manim/","title":"Introduction to Manim","text":"<ul> <li>Basics of running manim:</li> <li>If you have installed it , then make sure you have the community version which currently is the v\\(0.18.0\\) , and so basically what we will be doing is creating classes, and there are different type of Scenes in Manim  we will go there but later.., now we will just use Scene.</li> <li>Now manim has something called self which method we will use to create animation in the videos.</li> <li>So something like this, your code would look like:    ```python    from manim import *</li> </ul> <p>class MyScene(Scene):     def construct(self):         # Your animation code         text = Text(\"Hello, Manim!\")         self.play(Create(text))</p> <p><pre><code>Output:\n![MyScene.mp4](&lt;./MyScene.mp4&gt;)\n\n- To get the output you would do the following in your terminal with the same directory as your manim python file.\n```sh\nmanim (filename.py) (ClassName) -pqh \n</code></pre> here write those without the brackets and -pqh suggests, play quality high, you can use -pql, -pqm and -pqp, suggesting low, medium, production. H - 1080p60 L - 480p30 P - 1440p60 M - 720p30 k - 4k60fps</p>"},{"location":"Manim/Manim/","title":"Manim","text":"<p>Manim is a python library which will allow us to animate stuff.</p> <ul> <li>Introduction to Manim</li> <li>[[Why Manim?]]</li> <li>Text Animation in Manim</li> <li>General Animation in Manim</li> <li>Building Blocks of Manim</li> <li>Common Functions in Manim</li> <li>Transformation in Manim</li> <li>Bases of Transformation</li> <li></li> <li></li> <li>Scenes in Manim</li> </ul>"},{"location":"Manim/Text%20Animation%20in%20Manim/","title":"Text Animation in Manim","text":"<p>Hey there traveler, Welcome to the ship \ud83c\udf7b!</p> <p>Manim has something called mobjects, and text is one of them, you will read this word frequently so , it is just a set of objects that are available for you to write manim code.</p> <ul> <li>Manim has two types of Text Rendering, one is Simple Text which uses Pango Lib which can be useful to render non-English alphabets.And can be called by using:   <code>python   text = Text(\"Hello world\", font_size=144)   # or      text = MarkupText(         f'all in red &lt;span fgcolor=\"{YELLOW}\"&gt;except          this&lt;/span&gt;', color=RED         )</code></li> <li>While the other is called Tex( which you will majorly use) which is used like this: <pre><code>tex = Tex(r\"\\LaTeX\", font_size=144)\n</code></pre> <pre><code>#it allows attribute changing, like color for eg:\ntex = Tex(r'Hello \\LaTeX', color=BLUE, font_size=144)\n</code></pre> <pre><code>#you can write math function like:\n tex = MathTex(r'f(x) &amp;= 3 + 2 + 1\\\\ &amp;= 5 + 1 \\\\ &amp;= 6', font_size=96)\n</code></pre> </li> </ul>"},{"location":"Manim/Transformation%20in%20Manim/","title":"Transformation in Manim","text":"<ul> <li>As we saw in the Building blocks there are many simple function, now we dwell a little deeper into this transformation which will make things more interesting.</li> </ul>"},{"location":"Manim/Transformation%20in%20Manim/#_1","title":"Transformation in Manim","text":""},{"location":"Manim/Why%20Manim_/","title":"Why Manim","text":"<ul> <li> <p>You might be wondering, if manim is this code intensive, why manim?</p> <ul> <li>The answer might actually be just truly simple in all honesty, because it looks beautiful and you can do various operation which are really really hard in any other software, it is usually recommended to use when you have a hard data set of some sort of a function which is large and humanly hard to understand, and here's Grant explaining what should do: Grant's Interview with Lex</li> <li>\"Do as I say, not as I do\"- Grant Sanderson</li> </ul> </li> <li> <p>It is very math intensive and useful when generalizing formulas and explanations, it is very useful to create graphic intensive animation with ease, when you have multiple objects and small numbers which lead to large dataset, that's when manim shines it's light beautifully, the more you know.</p> </li> <li> <p>Here are some cool examples if you are interested:</p> </li> </ul>"},{"location":"Topic%201/Note%201/","title":"Note 1","text":"<p>Example: link to Mermaid Diagrams under <code>Features</code></p>"},{"location":"Topic%201/Note%202/","title":"Note 2","text":""},{"location":"blog/","title":"Blog","text":""}]}